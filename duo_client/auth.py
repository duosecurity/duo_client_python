"""
Duo Security Auth API reference client implementation.

<http://www.duosecurity.com/docs/authapi>
"""
import client

class Auth(client.Client):
    def ping(self):
        """
        Determine if the Duo service is up and responding.

        Returns information about the Duo service state: {
            'time': <int:UNIX timestamp>,
        }
        """
        return self.json_api_call('GET', '/auth/v2/ping', {})

    def check(self):
        """
        Determine if the integration key, secret key, and signature
        generation are valid.

        Returns information about the Duo service state: {
            'time': <int:UNIX timestamp>,
        }
        """
        return self.json_api_call('GET', '/auth/v2/check', {})

    def enroll(self, username=None, valid_secs=None):
        """
        Create a new user and associated numberless phone.

        Returns activation information: {
            'activation_barcode': <str:url>,
            'activation_code': <str:actcode>,
            'user_id': <str:autogenerated>,
            'username': <str:provided or autogenerated>,
            'valid_secs': <int:seconds>,
        }
        """
        params = {}
        if username is not None:
            params['username'] = username
        if valid_secs is not None:
            valid_secs = str(int(valid_secs))
            params['valid_secs'] = valid_secs
        return self.json_api_call('POST',
                                  '/auth/v2/enroll',
                                  params)

    def enroll_status(self, user_id, activation_code):
        """
        Check if a user has been enrolled yet.

        Returns a string constant indicating whether the user has been
        enrolled or the code remains unclaimed.
        """
        params = {
            'user_id': user_id,
            'activation_code': activation_code,
        }
        response = self.json_api_call('POST',
                                      '/auth/v2/enroll_status',
                                      params)
        return response

    def bypass_codes(self,
                     username=None,
                     user_id=None,
                     count=None,
                     valid_secs=None):
        """
        Generate bypass codes for the user, invalidating any existing codes.

        Returns an expiration time and the list of codes: {
            'codes': [ <str:code>, ... ],
            'expiration': <int:UNIX timestamp>,
        }
        """
        params = {}
        if username is not None:
            params['username'] = username
        if user_id is not None:
            params['user_id'] = user_id
        if count is not None:
            count = str(int(count))
            params['count'] = count
        if valid_secs is not None:
            valid_secs = str(int(valid_secs))
            params['valid_secs'] = valid_secs
        response = self.json_api_call('POST',
                                      '/auth/v2/bypass_codes',
                                      params)
        return response

    def preauth(self, username=None, user_id=None, ipaddr=None):
        """
        Determine if and with what factors a user may authenticate or enroll.
        """
        params = {}
        if username is not None:
            params['username'] = username
        if user_id is not None:
            params['user_id'] = user_id
        if ipaddr is not None:
            params['ipaddr'] = ipaddr
        response = self.json_api_call('POST',
                                      '/auth/v2/preauth',
                                      params)
        return response

    def auth(self,
             factor,
             username=None,
             user_id=None,
             ipaddr=None,
             async=False,
             type=None,
             display_username=None,
             pushinfo=None,
             device=None,
             passcode=None):
        """
        Perform second-factor authentication for a user.

        If async is True, returns: {
            'txid': <str: transaction ID for use with auth_status>,
        }

        Otherwise, returns: {
            'result': <str:allow|deny>,
            'status': <str:machine-parsable>,
            'status_msg': <str:human-readable>,
        }
        """
        params = {
            'factor': factor,
            'async': str(int(bool(async))),
        }
        if username is not None:
            params['username'] = username
        if user_id is not None:
            params['user_id'] = user_id
        if ipaddr is not None:
            params['ipaddr'] = ipaddr
        if type is not None:
            params['type'] = type
        if display_username is not None:
            params['display_username'] = display_username
        if pushinfo is not None:
            params['pushinfo'] = pushinfo
        if device is not None:
            params['device'] = device
        if passcode is not None:
            params['passcode'] = passcode
        response = self.json_api_call('POST',
                                      '/auth/v2/auth',
                                      params)
        return response

    def auth_status(self, txid):
        """
        Longpoll for the status of an asynchronous authentication call.

        Returns a dict with four items:

        * waiting: True if the authentication attempt is still in progress
          and the caller can continue to poll, else False.

        * success: True if the authentication request has completed and
          was a success, else False.

        * status: String constant identifying the request's state.

        * status_msg: Human-readable string describing the request state.
        """
        params = {
            'txid': txid,
        }
        response = self.json_api_call('GET',
                                      '/auth/v2/auth_status',
                                      params)
        return {
            'waiting': (response.get('result') == 'waiting'),
            'success': (response.get('result') == 'allow'),
            'status': response.get('status', ''),
            'status_msg': response.get('status_msg', ''),
        }
